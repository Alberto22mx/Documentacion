<?xml version="1.0" ?>
<cherrytree>
	<node custom_icon_id="0" foreground="" is_bold="False" name="MySQL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096592.81" ts_lastsave="1590096655.64" unique_id="1">
		<rich_text>
</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Introducción" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096655.64" ts_lastsave="1590098965.63" unique_id="2">
		<rich_text>
</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Sistema cliente-servidor" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097435.42" ts_lastsave="1590098994.6" unique_id="22">
			<rich_text scale="h1">Sistema cliente/ servidor</rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h3">Los tres componentes de hardware del sistema cliente/servidor.</rich_text>
			<rich_text>

Los clintes: PCs, Macs, workstations, dispositivos móviles, laptops, smartphones.
El servidor: es una computadora que almacena los archivos de la base de datos y provee servicio a los clientes. Cuado almacena bases de datos se dice que es un serviodr de base de datos.
La red: consiste en el cableado, líneas de comunicación, o cualquier otro componente que conecte los clientews con el sevidor.

</rich_text>
			<rich_text scale="h1">Software cliente, software servidor e interface sql.</rich_text>
			<rich_text>

Software del servidor: 

Quien almacena y maneja las bases de datos del sistema cliente-servidor, coda servidor requiere un sistema manejador de bases de datos (DBMS)  con  MySQL.
El proceso que hace el DBMS es conocido como back-end preocessing.

Software cliente:

La aplicación que trabaja para solicitar información al servidor. Este software puede ser desarrollado por ejemplo.
Por ejemplo al trabjar con Java tenemos una API (application programming interface) para MySQL como lo es JDBC (Java Database Connectivity).

Interfece SQL:

El software a la aplicacion se comunica con el DBMS mandando consultas SQL atraves de la API. Al recibir las peticiones el servidor provee un servicio que regresa los datos por medio de un Query Results.
SQL( Structured Query Languaje) es el lenguaje estándar para trabajar con bases de datos relacionales.

Un sistema cliente-servidor puede incluir servidores adicionales como servidores de aplicaciones y servidores web.

Los servidores de aplicaciones son usados típicacmente para almacenar componentes de negocio que hacen parte del proceso en las aplicaciones su función es mandar las consultas SQL al servidor y recibir las respuesta.

Un servidor web es típicamente usado para almacenar aplicaciones web y webservices.

En un sistema web un navegador web se ejecuta en el cliente, manda las peticiones al servidor web desde internet. Después el servidor web envía dichas peticiones al servidor de bases de datos.

Existen otras arquitecturas que incluyen dos o mas servidores de aplicaciones o web servers y servidores de bases de datos.</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Entidad relación" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590098783.27" ts_lastsave="1590098783.27" unique_id="23">
			<rich_text>
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Foreing keys" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590098929.23" ts_lastsave="1590098929.23" unique_id="24">
			<rich_text>
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Analisis de DB" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590098965.63" ts_lastsave="1590098971.38" unique_id="25">
			<rich_text>
</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Workbench" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096671.9" ts_lastsave="1590099285.15" unique_id="3">
		<rich_text>
</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Instalación" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590099297.94" ts_lastsave="1590099297.94" unique_id="26">
			<rich_text>
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Creando DB" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096716.68" ts_lastsave="1590099362.28" unique_id="5">
			<rich_text>
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Exportar e importar" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096739.41" ts_lastsave="1590099365.77" unique_id="6">
			<rich_text>trigarante2020-1.cypym5wo7yt3.us-east-1.rds.amazonaws.com
servici1
3306</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Linea de comandos" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096755.69" ts_lastsave="1592055045.62" unique_id="7">
		<rich_text>Ejecutar MySQL:

1- Entrar a: </rich_text>
		<rich_text link="fold QzpcUHJvZ3JhbSBGaWxlc1xNeVNRTFxNeVNRTCBTZXJ2ZXIgOC4wXGJpbg==">C:\Program Files\MySQL\MySQL Server 8.0\bin</rich_text>
		<rich_text>
2- Ejecutar: mysql -u root -p

Conexiín base en la nube:

1- Entrar a: </rich_text>
		<rich_text link="fold QzpcUHJvZ3JhbSBGaWxlc1xNeVNRTFxNeVNRTCBTZXJ2ZXIgOC4wXGJpbg==">C:\Program Files\MySQL\MySQL Server 8.0\bin</rich_text>
		<rich_text>
                                ip                  admin
2- Ejecutar: mysql - h hostname -u username -p

Crear base de datos:

</rich_text>
		<rich_text foreground="#1e1e9090ffff">create database db</rich_text>
		<rich_text>Pendientes;

Usar base de datos:

use dbEmployees

Ejecutar el archivo con su ruta pero si estamos al mismo nivel solo se usa el nombre para la importacion:

source </rich_text>
		<rich_text link="fold QzpcUHJvZ3JhbSBGaWxlc1xNeVNRTFxNeVNRTCBTZXJ2ZXIgOC4wXGJpbg==">C:\Program Files\MySQL\MySQL Server 8.0\bin</rich_text>
		<rich_text>\dbEmployees.sql


Comado mas rapido: 

maysql -u root -dbEmployees &lt; dbEmployees.sql o ruta.

Exportación:

</rich_text>
		<rich_text family="monospace">mysqldump</rich_text>
		<rich_text> -u root -p dbemployees &gt; </rich_text>
		<rich_text link="fold QzpcVXNlcnNcVWx0cm9uXERvY3VtZW50c1x0ZXN0">C:\Users\Ultron\Documents\test</rich_text>
		<rich_text>\dbemployees.sql;

Exportar tablas:

mysqldump -h localhost -u root -p dbemployees employees &gt; empleados.sql

Importar tabla:

mysql -h localhost -u root -p dbPendientes &lt; </rich_text>
		<rich_text link="fold QzpcVXNlcnNcVWx0cm9uXERvd25sb2Fkcw==">C:\Users\Ultron\Downloads</rich_text>
		<rich_text>\original.sql;</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Sentencias DDL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096767.14" ts_lastsave="1591312789.58" unique_id="8">
		<rich_text>
</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Bases de datos" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590931656.45" ts_lastsave="1592055816.55" unique_id="27">
			<rich_text>CREATE DATABASE IF NOT EXIST nombreDB; - Crea una base de datos si no existe.


DROP DATABASE IF EXIST employees; - Borra una base de datos si existe.

USE nombreDB; - Se lecciona una base de datos para su consulta.</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Tablas" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590936860.46" ts_lastsave="1592021622.76" unique_id="28">
			<rich_text>Sintaxis para la creación de una tabla.

CREATE TABLE [IF NOT EXISTS] dbNombre.nombreTabla
{
    nombreColumna tipoDeDato [atributo],
    nombreColumna tipoDeDato [atributo],
    [constrainsTabla]
}

DROP [TEMPORARY] TABLE [IF EXISTS] table_name [, table_name] ... [RESTRICT | CASCADE]

Atributos mas comunes.

NOT NULL - La columna no acepta nulos, si se omite este atributo puede aceptar nulos.
UNIQUE - Cada valor en la columna debe ser único.
DEFAULT default_valor - Especifica un valor default para la columna puede ser literal o una expresión.
AUTO_INCREMENT - Su valor es incrementado automáticamente por MySQL cuanod se agrefar un renglón, tienen que ser de tipo entrero o número con punto flotante.

Ejemplos:

CREATE TABLE clientes
(
	id int,
    nombreCliente varchar(30),
    ciudad varchar(30),
    telefono varchar(30)
);

CREATE TABLE IF NOT EXISTS bdtempora.productos
(
	id int NOT NULL UNIQUE AUTO_INCREMENT,
    nombreProducto varchar(30) UNIQUE,
    costo decimal(8, 2) NOT NULL default 0,
    precioVenta decimal(8, 2) NOT NULL default 0,
    existencia decimal(8, 2) NOT NULL default 0
);

Tabla tempora.

CREATE TEMPORARY TABLE tmpProductos AS SELECT * FROM productos;

Las tablas temporales no las muestra el schema.

SELECT * FROM tmpProductos;

Podemos hacer los mismo pero que no tenga datos solo pasa la estructura:

CREATE TABLE tmpProductos LIKE productos;</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Renombrar" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592021606.31" ts_lastsave="1592021636.06" unique_id="35">
				<rich_text>sintasis para renombrar una tabla&gt;

RENAME TABLE nombreAntiguo TO nuevoNombre;
</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Truncar" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592021615.06" ts_lastsave="1592023153.3" unique_id="36">
				<rich_text>Sintaxis para borrar toda la informacion

-- borra los datos de una tabla
truncate table detalleventa;</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Borrar" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592021622.76" ts_lastsave="1592023170.6" unique_id="37">
				<rich_text>-- elimina una tabla
drop table productos;

No borra si tienen integridad relacional</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Constraint" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590947506.77" ts_lastsave="1592007357.13" unique_id="29">
			<rich_text>Constrains: un constraint restringe los datos que pueden ser almacenados en una columna.

-Not null
-Primery key
-Uniqye

Tipos de constraint

Constraint a nivel de columna
Sintaxis nombreColumna tipoDeDato PRIMARY KEY atributosDeColumna

Ejemplo:

CREATE TABLE clientes
(
	id int PRIMARY KEY auto_increment,
    nombreCliente varchar(30) NOT NULL unique,
    ciudad varchar(30),
    telefono varchar(30)
)

Constaint a nivel de tabla
Sintaxis [CONSTRAINT [nombreContraint]]
    PRIMARY KEY (nombreColumna1 [nombreColumna2].....)
    
Ejemplo:

CREATE TABLE clientes
(
	id int auto_increment,
    nombreCliente varchar(30),
    ciudad varchar(30),
    telefono varchar(30),
    constraint clientes_pk primary key (id),
    constraint nombreClienet_uq unique (nombreCliente)
);
    
La ventaja de la segunda forma de los constains es que se pueden controlar los nombres.

</rich_text>
			<rich_text foreground="#1e1e9090ffff" scale="h1" weight="heavy">Creación desde el incio:</rich_text>
			<rich_text>

-- borramos la base de datos
drop database if exists bdTemporal;

-- creamos la base de datos
create database if not exists bdTemporal;

-- seleccionamos la base de datos
use bdTemporal;

-- crear una tabla que no tenga ningun atributo
CREATE TABLE clientes
(
  id int primary key auto_increment,
  nombreCliente varchar(30) not null unique,
  ciudad varchar (30),
  telefono varchar(30)
)ENGINE = InnoDB;

-- crear una tabla que tenga atributos en sus columnas y defina el nombre de la base de datos

CREATE TABLE IF NOT EXISTS bdTemporal.productos
(
  id int   not null     unique       auto_increment     ,
  nombreProducto varchar(30)   unique,
  costo decimal(8,2)           not null    default 0,
  precioVenta decimal(8,2)     not null    default 0,
  existencia decimal(8,2)      not null    default 0
)ENGINE = InnoDB;

-- creamos la tabla

CREATE TABLE IF NOT EXISTS detalleVenta
(
  id int   not null     unique       auto_increment     ,
  fechaVenta date not null,
  idClientes int not null,
  idProductos int not null,
  cantidadVendida decimal(8,2) not null,
  costo decimal(8,2)      not null    default 0,
  precioVenta decimal (8,2)
)ENGINE = InnoDB;










</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Foreing key" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1591138730.96" ts_lastsave="1591308116.34" unique_id="30">
				<rich_text>Una llave foránea o foreign key requiere valoresen una tabla y que coincidan con los valores de otra tabla, esto define la relación entre dos tablas y así forza la integridad referencial.

Sintaxis a nivel tabla del constraint foreign key:

    [CONSTRAINT [nombreConstraint]]
    FOREIGN KEY [index_name] (col_name, ....)
        FEFERENCES tbl_name (col_name, ....)
        [ON DELETE reference_option {CASCADE | SET NULL | NO ACTION | SET DEFAULT}]
        [ON UPDATE reference_option {CASCADE | SET NULL | NO ACTION | SET DEFAULT}]
        
        </rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Scripts" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1591309212.56" ts_lastsave="1591309249.59" unique_id="31">
				<rich_text>NOTA:on delete no action evita borrar un registro que tenga relación y on delete cascade elimina el registro y todos los registros con relación.

-- borramos la base de datos
drop database if exists bdTemporal;

-- creamos la base de datos
create database if not exists bdTemporal;

-- seleccionamos la base de datos
use bdTemporal;

-- crear una tabla que no tenga ningun atributo

CREATE TABLE clientes
(
  id int primary key auto_increment,
  nombreCliente varchar(30) not null unique,
  ciudad varchar (30),
  telefono varchar(30)
)ENGINE = InnoDB;

-- crear una tabla que tenga atributos en sus columnas y defina el nombre de la base de datos

CREATE TABLE IF NOT EXISTS bdTemporal.productos
(
  id int   not null     unique       auto_increment     ,
  nombreProducto varchar(30)   unique,
  costo decimal(8,2)           not null    default 0,
  precioVenta decimal(8,2)     not null    default 0,
  existencia decimal(8,2)      not null    default 0
)ENGINE = InnoDB;

-- creamos la tabla 

CREATE TABLE IF NOT EXISTS detalleVenta
(
  id int   not null     unique       auto_increment     ,
  fechaVenta date not null,
  idClientes int not null,
  idProductos int not null,
  cantidadVendida decimal(8,2) not null,
  costo decimal(8,2)      not null    default 0,
  precioVenta decimal (8,2)
)ENGINE = InnoDB;

-- creamos la tabla con integridad

CREATE TABLE IF NOT EXISTS detalleVenta
(
  id int   not null     unique       auto_increment     ,
  fechaVenta date not null,
  idClientes int not null,
  idProductos int not null,
  cantidadVendida decimal(8,2) not null,
  costo decimal(8,2)      not null    default 0,
  precioVenta decimal (8,2),
  
  constraint fkDetalleVentaProductos
  foreign key (idProductos)
  references productos (id)
  on delete no action,
  
  constraint fkDetalleVentaClientes
  foreign key (idClientes)
  references clientes (id)
  on delete no action
)ENGINE = InnoDB;

-- insertando 5 clientes en la tabla clientes
insert into clientes(id,nombreCliente,ciudad,telefono) values (1,'José Manuel García','Cd. de México','014898989');
insert into clientes(id,nombreCliente,ciudad,telefono) values (2,'Ma. del Carmen de Loera','Morelia','0143432389');
insert into clientes(id,nombreCliente,ciudad,telefono) values (3,'Victor Contreras','La Paz California','234323423432');
insert into clientes(id,nombreCliente,ciudad,telefono) values (4,'Manuel Felix','Fresnillo','354345345');
insert into clientes(id,nombreCliente,ciudad,telefono) values (5,'Julio Arteaga','Calera','345345353455');

-- insertando 3 productos en la tabla productos
insert into productos (id,nombreProducto,costo,precioVenta, existencia) values(1,'Teclado usb',100,130,5);
insert into productos (id,nombreProducto,costo,precioVenta, existencia) values(2,'Mouse alámbrico',120,170,6);
insert into productos (id,nombreProducto,costo,precioVenta, existencia) values(3,'Computadora de escritorio',1000,1300,2);

-- insertando 1 venta de dos productos para el cliente 1
insert into detalleVenta(id,fechaVenta,idClientes,idProductos,cantidadVendida,costo,precioVenta)
			values(1,'2019-12-31',1,1,2,100,130);
            
insert into detalleVenta(id,fechaVenta,idClientes,idProductos,cantidadVendida,costo,precioVenta)
			values(2,'2019-12-31',1,2,1,120,170);

-- INSERT QUE VIOLA LA INTEGRIDAD REFERENCIAL PORQUE EL CLIENTE QUE QUIERO INSERTAR NO EXISTE
insert into detalleVenta(id,fechaVenta,idClientes,idProductos,cantidadVendida,costo,precioVenta)
			values(3,'2019-12-31',10,30,1,120,170);

select * from detalleVenta</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Alter table" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1591312789.58" ts_lastsave="1592019251.52" unique_id="32">
			<rich_text>La sentencia ALTER TABLE nos sirve para agregar, borrar, modificar o renombrar columnas de una tabla de base de datos.

SINTAXIS:

ALTER TABLE [dbNombre.]nombreTabla(
    ADD nombreColumna tipoDeDato [atributosColumna] [FIRST|AFTER existing_column] |
    DROP COLUMN nombreColumna |
    MODIFY nombreColumna tipoDeDato [atributosColumna] |
    CHANGE COLUMN anteriorNombreColumna nuevoNombreColumna
)</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="ejemplos" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592006840.81" ts_lastsave="1592018749.11" unique_id="33">
				<rich_text>-- Mostrar estructura de la tabla productos
desc detalleVenta;

-- Agregar una columna a la tabla de productos llamada color
alter table productos
add color varchar(29);

-- Agregar una columna a la tabla de productos despues del campo costo
alter table productos
add color varchar(29) after costo;

-- Agregar una columna a la tabla de productos siendo el primer campo de la definicion ddl
alter table productos
add color1 varchar(29) first;

-- Borrar un campo de la tabla productos, la existencia (no se puede borrar algun campo que viole la integreidad referencial)
alter table productos
drop column existencia;

-- Cambiar el tamaño de una columna, no te dejara cambiarlo si violas el tamaño de los registros que ya tengan información
alter table productos
modify nombreProducto varchar(20) not null;
desc productos;

-- Cambiar el tipo de dato de una columna, no te permitira hacer el cambio si tu campo no acepta el tipo de dato con los datos que ya se tengan almacenados
-- Cambia el tipo de dato pero solo sin son compatibles int a float, char a varchar
alter table productos
modify nombreProducto char(20) not null;
desc productos;

-- Cambiar el valor default para un registro cuando se inserte
alter table productos
modify nombreProducto char(20) null default 'ValorPorDefault';

-- Cambiar el nombre de un campo
alter table productos
change column costo precioCompra decimal(8, 2);





















</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="constraints" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592019251.53" ts_lastsave="1592021391.1" unique_id="34">
				<rich_text>La sentencia ALTER TABLE nos srive para gregar, borrar, modificar o renombrar columnas de una tabla de base de datos, pero tambien nos sirve para agregar o borrar constraints como lo son llaves foraneas o llaves primarias.

SINTAXIS:

ALTER TABLE [dbNombre.]nombreTabla
{
    ADD PRIMARY KEY definicionDeConstraint or
    ADD [CONSTRAINT nombreConstraint] FOREIGN KEY definicionDeConstraint or
    DROP PRIMARY KEY or
    DROP FOREING KEY nombreConstraint
}

Ejemplo

-- agregar la llave primaria en la tabla detalleVenta siendo la llave primaria el campo id
ALTER TABLE bdTemporal.detalleVenta
ADD primary key (ID);

-- agregar las llaves foraneas que pertenecen a los campos idClientes y idProductos a la tabla detalleVenta

ALTER TABLE bdTemporal.detalleVenta
ADD
	constraint fkDetalleVentaClientes
	foreign key (idClientes)
	references clientes (id)
	on delete no action;
DESC detalleVenta;</rich_text>
			</node>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Sentencias DML" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096816.22" ts_lastsave="1595372654.45" unique_id="10">
		<rich_text foreground="#df9307" weight="heavy">¿Que es SQL?</rich_text>
		<rich_text weight="heavy">
</rich_text>
		<rich_text>
•</rich_text>
		<rich_text weight="heavy">SQL</rich_text>
		<rich_text> (por sus siglas en inglés </rich_text>
		<rich_text weight="heavy">Structured Query Language</rich_text>
		<rich_text>; en español lenguaje de consulta estructurada) es un lenguaje que da acceso a un sistema de gestión de bases de datos relacionales que permite especificar diversos tipos de operaciones en ellos.

•Es un lenguaje estándar por haberse visto consolidado por el Instituto Americano de Normas (ANSI) y por la Organización de Estándares Internacional (ISO).

•Está compuesto por comandos, cláusulas, operadores y funciones de agregado

[CrudWidowsForms]</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Select" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592054714.48" ts_lastsave="1592585460.84" unique_id="38">
			<rich_text foreground="#df9307" weight="heavy">USO DE SENTENCIAS SQL ( SELECT )</rich_text>
			<rich_text weight="heavy">
</rich_text>
			<rich_text>
•Una instrucción select nos sirve para extraer información de una o más tablas de una base de datos.•</rich_text>
			<rich_text weight="heavy">Sintaxis:</rich_text>
			<rich_text>      

    </rich_text>
			<rich_text weight="heavy">SELECT</rich_text>
			<rich_text>   campos_seleccionados 
      </rich_text>
			<rich_text weight="heavy">FROM</rich_text>
			<rich_text>   tablas_de_datos 
     [ </rich_text>
			<rich_text weight="heavy">WHERE</rich_text>
			<rich_text>   condición ]
     [ </rich_text>
			<rich_text weight="heavy">ORDER BY</rich_text>
			<rich_text> ordenar_por_lista_campos ]
     [ </rich_text>
			<rich_text weight="heavy">LIMIT</rich_text>
			<rich_text>   limite_de_renglones ]

1. </rich_text>
			<rich_text foreground="#00b0f0">SELECT </rich_text>
			<rich_text>id,nombre,telefono</rich_text>
			<rich_text foreground="#00b0f0"> FROM </rich_text>
			<rich_text>personas

2. </rich_text>
			<rich_text foreground="#00b0f0">SELECT </rich_text>
			<rich_text>*</rich_text>
			<rich_text foreground="#00b0f0"> FROM </rich_text>
			<rich_text>personas</rich_text>
			<rich_text foreground="#00b0f0"> </rich_text>
			<rich_text>
</rich_text>
			<rich_text foreground="#00b0f0">        WHERE </rich_text>
			<rich_text>id &gt;0 
</rich_text>
			<rich_text foreground="#00b0f0">        ORDER by </rich_text>
			<rich_text>nombre</rich_text>
			<rich_text foreground="#00b0f0"> </rich_text>
			<rich_text>
</rich_text>
			<rich_text foreground="#00b0f0">        LIMIT </rich_text>
			<rich_text>10

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<table char_offset="460" col_max="400" col_min="40">
				<row>
					<cell>  LAS 5 CLAUSULAS DE UN SELECT STATMENT
  </cell>
					<cell></cell>
				</row>
				<row>
					<cell>  CLAUSULA
  </cell>
					<cell>  DESCRIPCION
  </cell>
				</row>
				<row>
					<cell>  SELECT
  </cell>
					<cell>  Describe   las columnas en el Result   Set
  </cell>
				</row>
				<row>
					<cell>  FROM
  </cell>
					<cell>  Nombre   de las tablas de donde extraerá los datos
  </cell>
				</row>
				<row>
					<cell>  WHERE
  </cell>
					<cell>  Especifica   la condición a cumplir para que los datos se   incluyan en el Result   Set
  </cell>
				</row>
				<row>
					<cell>  ORDER   BY
  </cell>
					<cell>  Especifica   como serán ordenados los datos
  </cell>
				</row>
				<row>
					<cell>  LIMIT
  </cell>
					<cell>  Especifica   el número de renglones a regresar
  </cell>
				</row>
				<row>
					<cell>haz clic</cell>
					<cell>haz clic</cell>
				</row>
			</table>
			<node custom_icon_id="0" foreground="" is_bold="False" name="WHERE" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592155695.49" ts_lastsave="1592592876.55" unique_id="45">
				<rich_text>La clausula </rich_text>
				<rich_text foreground="#ff0000">WHERE</rich_text>
				<rich_text>: limita el set de resultados de una tabla en base a los criterios que especifiquemos.
      
</rich_text>
				<rich_text style="italic">      SINTAXIS</rich_text>
				<rich_text>
</rich_text>
				<rich_text style="italic">      WHERE expresion1 operador expresion2</rich_text>
				<rich_text>

Ejemplos:

select * from fechaEs where fecha = “2020-01-01”;

select *, left(nombre, 1)
from personas where left(nombre, 1) &lt; 'k';</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="AS" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592523186.46" ts_lastsave="1592523499.04" unique_id="58">
				<rich_text>AS nos ayuda a personalizar el nombre de los campos de forma visual solo para entender mejor la consulta pero no cambia el nombre del campo de la tabla solo es un alias.

select id, fechaES, monto * 2 as “Operación”
from entradaSaludaDinero
Where monto &gt;= 500;</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="IN" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592155840.83" ts_lastsave="1595857149.23" unique_id="47">
				<rich_text>•El operador IN se puede utilizar para validar si una lista de elementos son validos para mostrar

•Podemos combinar el operador </rich_text>
				<rich_text foreground="#1e1e9090ffff">IN</rich_text>
				<rich_text> con el operador </rich_text>
				<rich_text foreground="#1e1e9090ffff">NOT</rich_text>
				<rich_text>

•Podemos hacer uso de </rich_text>
				<rich_text foreground="#1e1e9090ffff">subconsultas</rich_text>
				<rich_text> en el operador IN

•      </rich_text>
				<rich_text weight="heavy">SINTAXIS</rich_text>
				<rich_text>

      </rich_text>
				<rich_text style="italic">WHERE test_expresión [NOT] IN</rich_text>
				<rich_text>
</rich_text>
				<rich_text style="italic">      ({subconsulta|expression_1 [, expression_2]…}) </rich_text>
				<rich_text>


select * from personas
where id in (1,2,3)

select * from personas
where id not in (1,2,3)

select * from personas
where nombre in ('jose', ‘juan’)</rich_text>
				<node custom_icon_id="0" foreground="" is_bold="False" name="Ejemplos" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1595857104.38" ts_lastsave="1595857104.38" unique_id="62">
					<rich_text></rich_text>
				</node>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="BETWEEN" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592155945.42" ts_lastsave="1592188997.58" unique_id="48">
				<rich_text>•El operador IN se puede utilizar para validar si una lista de elementos son validos para mostrar
•Podemos combinar el operador IN con el operador NOT
•Podemos hacer uso de subconsultas en el operador IN
•      </rich_text>
				<rich_text weight="heavy">SINTAXIS</rich_text>
				<rich_text>

      </rich_text>
				<rich_text style="italic">WHERE test_expresión [NOT] IN</rich_text>
				<rich_text>
</rich_text>
				<rich_text style="italic">      ({subconsulta|expression_1 [, expression_2]…}) </rich_text>
				<rich_text>


</rich_text>
				<rich_text foreground="#1e1e9090ffff">SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;</rich_text>
				<rich_text>

</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="OPERADORES" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592147447.55" ts_lastsave="1592156561.33" unique_id="42">
				<rich_text>
</rich_text>
				<node custom_icon_id="0" foreground="" is_bold="False" name="ARITMETICOS" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592131954.56" ts_lastsave="1592155640.06" unique_id="40">
					<rich_text>
</rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
</rich_text>
					<table char_offset="1" col_max="400" col_min="40">
						<row>
							<cell>  Operador
  </cell>
							<cell>  Operador
  </cell>
							<cell>  Orden de Precedencia
  </cell>
						</row>
						<row>
							<cell>  *
  </cell>
							<cell>  Multiplicación
  </cell>
							<cell>  1
  </cell>
						</row>
						<row>
							<cell>  /
  </cell>
							<cell>  División
  </cell>
							<cell>  1
  </cell>
						</row>
						<row>
							<cell>  DIV
  </cell>
							<cell>  División   Entera
  </cell>
							<cell>  1
  </cell>
						</row>
						<row>
							<cell>  %   (MOD)
  </cell>
							<cell>  Módulo   ( Residuo)
  </cell>
							<cell>  1
  </cell>
						</row>
						<row>
							<cell>  +
  </cell>
							<cell>  Suma
  </cell>
							<cell>  2
  </cell>
						</row>
						<row>
							<cell>  -
  </cell>
							<cell>  Resta
  </cell>
							<cell>  2
  </cell>
						</row>
						<row>
							<cell>haz clic</cell>
							<cell>haz clic</cell>
							<cell>haz clic</cell>
						</row>
					</table>
				</node>
				<node custom_icon_id="0" foreground="" is_bold="False" name="COMPARACION" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592155625.35" ts_lastsave="1592155667.58" unique_id="44">
					<rich_text>
</rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
</rich_text>
					<table char_offset="1" col_max="400" col_min="40">
						<row>
							<cell>  OPERADORES DE COMPARACION
  </cell>
							<cell></cell>
						</row>
						<row>
							<cell>  SIGNO
  </cell>
							<cell>  DESCRIPCION
  </cell>
						</row>
						<row>
							<cell>  =
  </cell>
							<cell>  Igual
  </cell>
						</row>
						<row>
							<cell>  &lt;
  </cell>
							<cell>  Menor   que
  </cell>
						</row>
						<row>
							<cell>  &gt;
  </cell>
							<cell>  Mayor   que
  </cell>
						</row>
						<row>
							<cell>  &lt;=
  </cell>
							<cell>  Menor   igual que
  </cell>
						</row>
						<row>
							<cell>  &gt;=
  </cell>
							<cell>  Mayor   igual que
  </cell>
						</row>
						<row>
							<cell>  &lt;&gt;
  </cell>
							<cell>  Distinto   de
  </cell>
						</row>
						<row>
							<cell>  !=
  </cell>
							<cell>  Distinto   de
  </cell>
						</row>
						<row>
							<cell>haz clic</cell>
							<cell>haz clic</cell>
						</row>
					</table>
				</node>
				<node custom_icon_id="0" foreground="" is_bold="False" name="LOGICOS" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592155766.13" ts_lastsave="1592595291.8" unique_id="46">
					<rich_text>
</rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>

select * from personas
where id!=8 and left(telefono,3)='393' and id mod 2 = 0;

select * from personas
where not left(telefono,3)='393';</rich_text>
					<table char_offset="1" col_max="400" col_min="40">
						<row>
							<cell>  OPERADORES LOGICOS
  </cell>
							<cell></cell>
						</row>
						<row>
							<cell>  SIGNO
  </cell>
							<cell>  DESCRIPCION
  </cell>
						</row>
						<row>
							<cell>  AND
  </cell>
							<cell>   “Y”
  </cell>
						</row>
						<row>
							<cell>  OR
  </cell>
							<cell>  “O”
  </cell>
						</row>
						<row>
							<cell>  NOT
  </cell>
							<cell>  “NO”
  </cell>
						</row>
						<row>
							<cell>haz clic</cell>
							<cell>haz clic</cell>
						</row>
					</table>
				</node>
				<node custom_icon_id="0" foreground="" is_bold="False" name="Regexp" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592156130.53" ts_lastsave="1592156392.14" unique_id="49">
					<rich_text>
</rich_text>
					<rich_text foreground="#f9b639" weight="heavy">Regexp Operators</rich_text>
					<rich_text>

•Los operadores LIKE o REGEXP sirven para recuperar renglones que tengan un patrón llamado máscara. La máscara determina que valores satisfacen la condición.
•La máscara para el LIKE puede contener símbolos especiales llamados wildcards o comodines. La máscara para REGEXP contiene constructores y caracteres especiales. Usando máscara con REGEXP se puede decir que no es CASE-SENSITIVE.


</rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>


</rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
</rich_text>
					<table char_offset="409" col_max="400" col_min="40">
						<row>
							<cell>  LIKE wilcards
  </cell>
							<cell></cell>
						</row>
						<row>
							<cell>  SIMBOLO
  </cell>
							<cell>  Descripción
  </cell>
						</row>
						<row>
							<cell>  %
  </cell>
							<cell>   Coincide con una cadena de cero o más   caracteres
  </cell>
						</row>
						<row>
							<cell>  -
  </cell>
							<cell>  Coincide   con cualquier carácter.
  </cell>
						</row>
						<row>
							<cell>haz clic</cell>
							<cell>haz clic</cell>
						</row>
					</table>
					<table char_offset="413" col_max="400" col_min="40">
						<row>
							<cell>  REGEXP caracteres especiales y constructores
  </cell>
							<cell></cell>
						</row>
						<row>
							<cell>  Carácter   /constructor
  </cell>
							<cell>  Descripción
  </cell>
						</row>
						<row>
							<cell>  ^
  </cell>
							<cell>  Coincide   con el patrón desde el comienzo del valor que se prueba.
  </cell>
						</row>
						<row>
							<cell>  $
  </cell>
							<cell>  Coincide   con el patrón al final de el valor testeado
  </cell>
						</row>
						<row>
							<cell>  -
  </cell>
							<cell>  Coincide   con cualquier valor
  </cell>
						</row>
						<row>
							<cell>  [charlist]
  </cell>
							<cell>  Coincide   con cualquier carácter dentro de los corchetes.
  </cell>
						</row>
						<row>
							<cell>  [char1-char2]
  </cell>
							<cell>  Coincide   con cualquier carácter entre el rango dado.
  </cell>
						</row>
						<row>
							<cell>  |
  </cell>
							<cell>  Separa   dos patrones de cadena y coincide cada uno.
  </cell>
						</row>
						<row>
							<cell>haz clic</cell>
							<cell>haz clic</cell>
						</row>
					</table>
				</node>
				<node custom_icon_id="0" foreground="" is_bold="False" name="LIKE" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592156449.82" ts_lastsave="1592156461.99" unique_id="50">
					<rich_text>•El operador LIKE se puede utilizar regresar renglones que coincidan con un patrón llamado mascara. La mascara determina que valores en la columna satisface la condición.
•La mascara para el operador LIKE puede contener símbolos especiales llamados  wilcards las cuales son NO CASE-SENSITIVE
•Podemos hacer uso de el operador NOT en el operador LIKE para negar los resultados.
•      </rich_text>
					<rich_text weight="heavy">SINTAXIS</rich_text>
					<rich_text>

      </rich_text>
					<rich_text style="italic">WHERE match_expression [NOT] LIKE pattern</rich_text>
					<rich_text>
</rich_text>
				</node>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="FUNCIONES PROPIAS DE MYSQL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592131726.97" ts_lastsave="1595856432.59" unique_id="39">
				<rich_text>
</rich_text>
				<rich_text foreground="#df9307" weight="heavy">USO DE FUNCIONES PROPIAS DE MYSQL BASICAS</rich_text>
				<rich_text weight="heavy">
</rich_text>
				<rich_text>
•MySQL al igual que los lenguajes de programación más comunes tiene sus propias funciones para hacernos más fácil el manejo de sentencias SQL.
•Algunas de las funciones más utilizadas son:

</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text>
</rich_text>
				<table char_offset="234" col_max="400" col_min="40">
					<row>
						<cell>  Función
  </cell>
						<cell>  Sintaxis
  </cell>
						<cell>  Descripción
  </cell>
					</row>
					<row>
						<cell>  CONCAT
  </cell>
						<cell>  CONCAT   (cadena1[,cadena2]….)
  </cell>
						<cell>  Une   o concatena dos o más cadenas y regresa una única cadena.
  </cell>
					</row>
					<row>
						<cell>  LEFT
  </cell>
						<cell>  LEFT(cadena,   numeroDeCaracteres)
  </cell>
						<cell>  Regresa   el número de caracteres de la izquierda de una cadena que especifiquemos en numeroDeCaracteres
  </cell>
					</row>
					<row>
						<cell>  DATE_FORMAT
  </cell>
						<cell>  DATE_FORMAT(fecha,formato)
  </cell>
						<cell>  Da   formato a una fecha determinada
  </cell>
					</row>
					<row>
						<cell>  ROUND
  </cell>
						<cell>  ROUND(NUMERO[,numeroDeDecimales])
  </cell>
						<cell>  Redondea   un número a la cantidad de decimales que especifiquemos
  </cell>
					</row>
					<row>
						<cell>haz clic</cell>
						<cell>haz clic</cell>
						<cell>haz clic</cell>
					</row>
				</table>
				<node custom_icon_id="0" foreground="" is_bold="False" name="USO DE FUNCIONES " prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592132049.24" ts_lastsave="1592132073.86" unique_id="41">
					<rich_text>•</rich_text>
					<rich_text foreground="#ffc000">Función </rich_text>
					<rich_text foreground="#ffc000" weight="heavy">LEFT: </rich_text>
					<rich_text weight="heavy">función que trabaja con cadenas y extrae el número de caracteres que se indique como parámetro</rich_text>
					<rich_text> </rich_text>
					<rich_text style="italic">     Sintaxis</rich_text>
					<rich_text>
</rich_text>
					<rich_text style="italic">     LEFT (cadena, numero_de_caracteres)</rich_text>
					<rich_text>
     
•</rich_text>
					<rich_text foreground="#ffc000">Función </rich_text>
					<rich_text foreground="#ffc000" weight="heavy">DATE_FORMAT: </rich_text>
					<rich_text weight="heavy">función que da formato a las columnas de tipo fecha.</rich_text>
					<rich_text style="italic" weight="heavy">     Sintaxis:</rich_text>
					<rich_text style="italic">
</rich_text>
					<rich_text style="italic" weight="heavy">     DATE_FORMAT (fecha, formato_de_cadena)</rich_text>
					<rich_text style="italic">
     
•</rich_text>
					<rich_text foreground="#ffc000" style="italic">Función  </rich_text>
					<rich_text foreground="#ffc000" style="italic" weight="heavy">ROUND:</rich_text>
					<rich_text style="italic" weight="heavy"> función para dar formato respecto al redondeo a datos numéricos.</rich_text>
					<rich_text style="italic">     Sintaxis:</rich_text>
					<rich_text>
</rich_text>
					<rich_text style="italic">     ROUND(número[,número_de_decimales</rich_text>
					<rich_text>])
</rich_text>
					<node custom_icon_id="0" foreground="" is_bold="False" name="Ejemplos" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592570279.17" ts_lastsave="1592582703.17" unique_id="60">
						<rich_text>select id,fechaES,date_format(fechaES,'%d/%m/%y') as 'fecha1',date_format(fechaES,'%e-%b-%Y') as 'fecha2',
observaciones,left(observaciones,10) as 'primeras10',
montoIE, round(montoIE, 1) as 'redondeo',
from entradaSlidaDinero
where id&gt;500;

SELECT current_date(),date_format(current_date(), '%M/%D/%Y');

SELECT &quot;HOLA MUNDO&quot; AS &quot;CADENA&quot;, LEFT(CONCAT(&quot;HOLA MUNDO&quot;, &quot;HOY ES UN BUEN DÍA&quot;), 20) AS &quot;CADENA2&quot;;

SELECT SUM(10+15), ROUND(154.693, 2) AS &quot;REDONDEADO&quot;;</rich_text>
					</node>
				</node>
				<node custom_icon_id="0" foreground="" is_bold="False" name="CONCATENAR" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592147520.74" ts_lastsave="1592147605.14" unique_id="43">
					<rich_text foreground="#df9307" weight="heavy">FUNCION CONCAT ( CONCATENAR)</rich_text>
					<rich_text>

•La función </rich_text>
					<rich_text foreground="#ff0000">CONCAT</rich_text>
					<rich_text> nos sirve para unir una o más cadenas para finalmente regresar una única cadena de texto, incluso podemos concatenar funciones propias de MySql que regresen otro tipo de valor.•     

Sintaxis

•CONCAT (string1 [, string2]….)</rich_text>
				</node>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="IS NULL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592156567.77" ts_lastsave="1592156638.8" unique_id="51">
				<rich_text>•El uso de la clausula IS NULL es para preguntar a la base de datos campos sin valor es decir nulos, no hay que confundirlos con cadena vacia (‘’) o con un valor cero.
• </rich_text>
				<rich_text weight="heavy">SINTAXIS</rich_text>
				<rich_text>

      </rich_text>
				<rich_text style="italic">WHERE expression IS [NOT] NULL</rich_text>
				<rich_text>
</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="ORDER BY" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592156626.54" ts_lastsave="1592156656.15" unique_id="52">
				<rich_text>•El uso de la clausula ORDER BY es para especificar como nuestros renglones en el set de resultados serán ordenados. Puedes ordenarlos por mas de una columna, al mismo tiempo puedes ordenarlas de forma ascendente (ASC) o descendente ( DESC ) por default es ASC.
•Puedes ordenar por cualquier campo que aparezca en tu clausula SELECT       

</rich_text>
				<rich_text weight="heavy">SINTAXIS</rich_text>
				<rich_text>

      </rich_text>
				<rich_text style="italic">ORDER BY expression [ASC|DESC] [, expression [ASC|DESC]]…</rich_text>
				<rich_text>
</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="LIMIT" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592156705.07" ts_lastsave="1592156712.11" unique_id="53">
				<rich_text>•LIMIT limita el número de renglones regresados por una sentencia SELECT, puede tener uno o dos parámetros.
•</rich_text>
				<rich_text weight="heavy">Con un simple argumento le especificamos el </rich_text>
				<rich_text>número</rich_text>
				<rich_text weight="heavy"> máximo de registros a regresar empezando desde el primer registro. Al codificar los dos parámetros el offset especifica el primer renglón a regresar.</rich_text>
				<rich_text>
•</rich_text>
				<rich_text weight="heavy">Regularmente LIMIT va de la mano con la clausula ORDER BY.</rich_text>
				<rich_text>

•</rich_text>
				<rich_text weight="heavy">SINTAXIS</rich_text>
				<rich_text>
      </rich_text>
				<rich_text style="italic">LIMIT [offset,] row_count</rich_text>
				<rich_text>
</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="AGREGADOS" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592158725.49" ts_lastsave="1592523836.52" unique_id="56">
				<rich_text>Funciones y consultas de agregado

Se utilizan para resumir por ejemplo las ventas de vendedor, los pagos de un trabajador etc.
Para sacar el máximo o mínimi valor de una lista de datos.

AVG ([ALL  | DISTINCT] expresión) - El promedio de los valores no nulos en la consulta realizada.
SUM ([ALL  | DISTINCT] expresión) - El total o suma de los valores no nulos en la consulta realizada.
MIN ([ALL  | DISTINCT] expresión) - El valor minimo de los registros de la consulta realizada.
MAX ([ALL  | DISTINCT] expresión) - El valor maximo de los regtistros de la consulta realizada.
COUNT ([ALL  | DISTINCT] expresión) - El número total de registros de la consulta realizada.
COUNT (*) - El número total de registros de la cosulta realizada.

-- Cuanto trabajadores existen en la tabla employees
select count(*) from employees;

--Cuanto trabajadores cumplen años en cada mes del año.
select month(birth_data), count(*)
from employees
group by 1
order by 1;

--Cuanto trabajadores cumplen años en cada dia del mes del año diferente.
select month(birth_data), day(birth_data), count(*)
from employees
group by 1, 2
order by 1, 2;</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="JOIN" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592158016.47" ts_lastsave="1592188445.97" unique_id="55">
				<rich_text>Uso de inner join.

Un Join combina las columnas de dos o mas tablas en un mismo resultset basado en las condiciones que se especifiquen. Mostrando así solo los renglones que satisfacen dicha condición.

Una condición de unión nombra una columna en cada una de las dos tablas involucradas en la unión e indica cómo deben compararse las dos columnas por lo general con el signo igual.

Las tablas son unidas típicamente en la relación mediante la llave primaria de una tabla con la llave foránea de la otra.

Si las dos columnas en el JOIN tienen el mismo nombre, hay que diferenciarlo por medio del nombre de la tabla.nombrecampo

Sintaxis:

SELECT select_lit
FROM table_1
    [INNER] JOIN table_2 ON join_codition_1
    [INNER] JOIN table_3 ON join_codition_2
    
    
Ejemplos:

select *
from entradaSalidaDinero
inner join personas on entradaSalidaDinero.idPersonas = personas.id;

select personas.id, entradasalidadinero.id
from entradaSalidaDinero
inner join personas on entradaSalidaDinero.idPersonas = personas.id;











































</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="DISTINCT" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592585460.84" ts_lastsave="1592590034.94" unique_id="61">
				<rich_text>-- Quita todos los elementos repetidos
select distinct fechaES
from entradaSalidaDinero;
select distinct fechaES, count(distinct fechaES)
from entradaSalidaDinero;
select distinct year(fechaES)
from entradaSalidaDinero;
select distinct(idEstatusPendientes)
from pendientes;</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Insert" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592157892.18" ts_lastsave="1592522306.31" unique_id="54">
			<rich_text>-- creamos una copia de una tabla personas

create table tmpPersonas as
select * from Personas;

-- borramos la tabla tmppersonas
drop table tmppersonas;

-- creamos una copia de una tabla personas si datos

create table tmpPersonas as
select * from Personas
where id = -1;

Nota no se crean las relaciones.

Sintaxis instruccion insert sql:

INSERT INTO nombre_tabla [(lista_columnas)]
VALUES (expresion1[, expresion2].....)

La instrucción insert nos sirve para agregar uno o más registros en una tabla de la base de datos.

En la clausula insert hay que especificar el nombre de la tabla con una lista de campos (opciona).

Incluye también la lista de valores en la cual si especificaste los nombres de los campos, esta debería llevar el mismo orden de los campos como los declaraste.

-- insertamos un renglo si usar la lista de las columnas
insert into tmpPersonas
values (0, 'Jaime', 'jaime@tmppersonas.com', '22334433221')

-- hacemos la insercipon de un registro para la tabla se usuarios
-- haciendo uso de los nombres de las columnas

insert into usuarios(nombre, password, idPersona)
values('Pedro', ‘Administrado’, 13)

Se tiene que tener cuidado al agregar un registro que tiene llaves fornareas ya que estas tienen que coincidir o de lo contrario puede ocacionar algun error.

-- hacemos un insert multiple con varios registros en una misma instruccion
insert into tmpPersonas values
(0, ‘Juan’, ‘juan@correo.com’, ‘34525234532’),
(1, ‘Juan’, ‘juan@correo.com’, ‘34525234532’),
(2, ‘Juan’, ‘juan@correo.com’, ‘34525234532’)

-- insertar todos los registros de la tabla personas hacia la tabla tmppersonas
-- pero solo los que tengan correo de hotmail
delete from tmppersonas;
select * from tmppersonas;

insert into tmppersonas
select * from personas
where correo like '%hotmail%';

Nota la inseción de los datos puede ser tan compleja como se necesite pero tienen que tener la misma estructura de los datos.


</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Update" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097008.89" ts_lastsave="1592519083.22" unique_id="13">
			<rich_text>Sintaxis instrucción update sql.

UPDATE nombre_tabla
SET nombre_columna = valor
WHERE condición;

La instrucción UPDATE modifica uno o más registros en una tabla.

En la clausula SET, puedes llamar el nombre de una o mas columnas y asignarle su nuevo valor.

En la clausula WHERE puedes especificar una condición bajo la cual serán modificados los renglones.

Ejemplo:

update usuarios
set password = 'NuevoDato'
where idPersona in(select id from personas where correo like '%hotmail%');

select * from tmppersonas;

select * from personas;

-- actualizar una tabla apartir de otra tabla en la que la primer tabla
-- solo traen nombre las personas y en la segunda ya traen apellido

update personas
set personas.nombre =  (select tmpperosnas.nombre from tmppersonas where personas.id=tmppersonas.id)
where personas.id=       (select tmpperosnas.id from tmppersonas where personas.id=tmppersonas.id)


</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Delete" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097013.84" ts_lastsave="1592177057.56" unique_id="14">
			<rich_text>SINTAXIS INSTRUCCION DELETE.

DELETE FROM nombre_tabla WHERE condición.

La clausula delete nos sirve para borrar una o mas registros de una tabla.
La clausula where se utiliza para escribir una condición bajo la cual será o serán eliminados los registros que cumplan dicha condicón.
Se puede utlilizar una subconsulta dentro de la clausula where.
un constraint de foreing-key nos previene de no eliminar registros que tengan relación con otras tablas.

-- borrar los registros que el tamaño de cadena del nombre sea mayor o igual a 15 de la tabla tmppersonas
delete from tmppersonas where nombre &gt;= length(15);

delete from usuarios
where idPersonas in(select id from personas where id &lt;=3)</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Funciones de agregación" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590096980.39" ts_lastsave="1592520598.08" unique_id="12">
		<rich_text>
</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Sentecias DCL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097024.98" ts_lastsave="1592176859.83" unique_id="15">
		<rich_text>Seguridad de base de datos.

La seguridad en las bases de datos es mediante instrucciones SQL ya se a para crear usurarios o mediante configuraciones workbench para dar seguridad a ciertas tareas.

</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Programas almacenados" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097043.47" ts_lastsave="1592178013.8" unique_id="16">
		<rich_text>
</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="views" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1592178000.87" ts_lastsave="1592569856.88" unique_id="57">
			<rich_text>Trabajando con vistas (views)

Las vistas son guardadas en la base de datos para ser más accesibles, están compuestas de una claususla select con una o más tablas de la base de datos, con funciones sin funciones propias del lenguaje sql..

Ventajas:

Limitan la exposición de las tablas a los usuarios permitiendoles solo mostrar la información que se desee.
Ocultan la complefidad en la extracción de datos para los usuarios o programadores.
Con ciertas restrincciones las vistas pueden ser utilizadas para actualizar, borrar e insertar datos hacia la base de datos.
Es más rapido que usar los querys.

Se escribe: create view NombreVista as
Estructura select, update, delete.

Para la creación de las vistas y se guardan debajo de la base de datos en la sección de views.

Para consultar una view solo tenemos que ejecutar: select &quot; from nombreView;

Ejemplo:

create view PersonasView as
select nombre, correo, telefono from personas;

Para editar una vista:

create or replace view PersonasView as
select nombre, correo, telefono from personas;

Para eliminar una vista:
drop view personasview;

Se puede actualizar una tabla usando una vista pero tienen algunas restrincciónes

No puede afectar a tablas con UNION.
No afecta a tablas con DISTIN.
Ni tablas que tengan restricciones con llaves foraneas.

Para actualizar se usa:

update personasview
set nombre = concat(nombre, “-”)









































</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Dynamic SQL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097058.51" ts_lastsave="1590097064.65" unique_id="17">
		<rich_text>
</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Transacciones" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097078.4" ts_lastsave="1590097094.34" unique_id="18">
		<rich_text>
</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Char set y collations" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097094.34" ts_lastsave="1590097110.56" unique_id="19">
		<rich_text>
</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="SQL y Execel" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097110.56" ts_lastsave="1590097124.53" unique_id="20">
		<rich_text>
</rich_text>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="SQL en un servidor" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1590097124.53" ts_lastsave="1590097124.53" unique_id="21">
		<rich_text>
</rich_text>
	</node>
</cherrytree>
