<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <bookmarks list=""/>
  <node name="Phaser" unique_id="1" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585671608" ts_lastsave="1738418699">
    <node name="Instalación" unique_id="3" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585673645" ts_lastsave="1585841850">
      <rich_text>Lo primero que se necesita es instalar nodejs.</rich_text>
      <node name="Extenciones visual studio" unique_id="2" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585672664" ts_lastsave="1585841773">
        <rich_text>live server
code runner</rich_text>
      </node>
      <node name="Descargar phaser" unique_id="4" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585673666" ts_lastsave="1585674069">
        <rich_text>Podemos dirigirnos a la pagina de descargar  y descargarlo directamente el archivo min:

</rich_text>
        <rich_text link="webs https://phaser.io/download">https://phaser.io/download</rich_text>
        <rich_text>

También podemos instalarlo por medio de la consola.

npm init -y
npm install phaser

Con esto se crea el proyecto de phaser.

Tambien vamos a instalar Phaser-cli:

</rich_text>
        <rich_text link="webs https://www.npmjs.com/package/phaser-cli">https://www.npmjs.com/package/phaser-cli</rich_text>
        <rich_text>

npm i -g phaser3-cli-gamma

Phaser-cli es una herramienta para crear proyectos de phaser de forma más rapida y sensilla, ahora que ya esta instalado falta probar instalando un proyecto:

pg --new test

poner datos de prueba y listo.</rich_text>
      </node>
      <node name="Estructura" unique_id="5" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585841850" ts_lastsave="1585846021">
        <rich_text>Una vez que se a descargado phaser correctamente ahora se tiene que crear la estrutura en donde emplearemos phaser.

Para tener un buen orden tenemos que crear un index y dentro crear un div contenedor con la siguiente estructura:

&lt;div id="contenedor"&gt;&lt;/div&gt;
&lt;script src="./node_modules/phaser/dist/phaser-arcade-physics.min.js"&gt;&lt;/script&gt;
&lt;script src="./src/main.js"&gt;&lt;/script&gt;


Dentro del vamos la referencia hacia phaser y otro archivo que tambien tenemos que crear dentro de una carpeta src.

Una vez creada la carpeta src y el archivo main ahora hace falta la estructura basica de un proyecto phaser, dentreo de main debemos tener un codigp como el siguiente:

</rich_text>
        <rich_text foreground="#1e1e9090ffff">//Esta es la configuración que tendra tu juego los atributos son muy explicitos.
const config = {
    //Con figuración opcional
    title: 'Curso phaser', //Titulo de tu juego
    url: 'http://google.es',//Pagina de tu juego
    version: '0.0.1', //Versión de tu juego
    //Configuración necesaria
    typo: Phaser.AUTO, //Tipo de rencerisado existen Phaser.AUTO, Phaser.CANVAS y Phaser.WEBGL
    width: 640,
    height: 360,
    parent: 'contenedor', //En esta opción se tiene que colocar el id del div de en donde se va a renderizar el juego
    pixelArt: true, //Solo se usa si esta desarrollado para pixelart
    backgroundColor: '#34495e', //Cambia el color de fondo del juego
    //Esto edita la información mostrada del proyecto en consola.
    banner: {
        hidePhaser: true,
        text: '#fff00f',
        background: ['#ff0000'] //Pedemos pasar varios colores
    },

    scene: {} //Aqui se crean los mundos de phaser por escenas
};

//Por ultimos instanciamos Phaser para crear el primer proyecto
const game = new Phaser.Game(config);</rich_text>
        <rich_text>

Vamos a descargar las definiciones de phaser para el autocompletado lo podemos descargar del curso de phaser.

Creamos una carpeta llamada def y colocamos el archivo.

ahora al nivel del proyecto creamos un archivos llamado jsconfig.json y dentro escribimos solo {} y lo guardamos.

</rich_text>
      </node>
    </node>
    <node name="Escenas" unique_id="6" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585847636" ts_lastsave="1585849305">
      <rich_text>Para tener un buen contros de las escenas vamos a crear su propia carpeta llamada scenes, detro vamos a colocar todas las escenas.

Las escenas son archivos con extención js con algunas configuración que se veran en los ejemplos.

Estas escenas creadas dentro de la nueva carpeta son las que vamos a usar dentro de la configuración que usemos para nuestro videojuegos.

Para complementar la información de las escenas es necesario que se descarque el proyecto que cuenta con todas estructura de forma detallada:

</rich_text>
      <rich_text link="webs https://github.com/Alberto22mx/Phaser.git">https://github.com/Alberto22mx/Phaser.git</rich_text>
      <node name="ejemplos" unique_id="7" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585848632" ts_lastsave="1585850157">
        <node name="1" unique_id="8" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585849553" ts_lastsave="1738418131">
          <rich_text>//Esta es la configuración que tendra tu juego los atributos son muy explicitos.
</rich_text>
          <codebox char_offset="81" justification="left" frame_width="1305" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">const config = {
    //Con figuración opcional
    title: 'Curso phaser', //Titulo de tu juego
    url: 'http://google.es',//Pagina de tu juego
    version: '0.0.1', //Versión de tu juego
    //Configuración necesaria
    typo: Phaser.AUTO, //Tipo de rencerisado existen Phaser.AUTO, Phaser.CANVAS y Phaser.WEBGL
    width: 640,
    height: 360,
    parent: 'contenedor', //En esta opción se tiene que colocar el id del div de en donde se va a renderizar el juego
    pixelArt: true, //Solo se usa si esta desarrollado para pixelart
    backgroundColor: '#34495e', //Cambia el color de fondo del juego
    //Esto edita la información mostrada del proyecto en consola.
    banner: {
        hidePhaser: true,
        text: '#fff00f',
        background: ['#ff0000'] //Pedemos pasar varios colores
    },
    //Aqui se crean los mundos de phaser por escenas
    scene: {
        init,
        preload,
        create,
        update
    }
};

//Por ultimos instanciamos Phaser para crear el primer proyecto
const game = new Phaser.Game(config);

function init() {
    console.log('Init');
}
function preload() {
    console.log('preloas');
}
function create() {
  console.log('create');
}
function update(time, delta) {
    
}</codebox>
        </node>
        <node name="Escenas separadas" unique_id="9" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585850157" ts_lastsave="1738426413">
          <rich_text>Para crear multiples escenas es necesario importar desde el main:



y agregar type="module" a la etiqueta src del main en el index.

</rich_text>
          <rich_text foreground="#808080">&lt;</rich_text>
          <rich_text foreground="#569cd6">script</rich_text>
          <rich_text foreground="#d4d4d4"> </rich_text>
          <rich_text foreground="#9cdcfe">src</rich_text>
          <rich_text foreground="#d4d4d4">=</rich_text>
          <rich_text foreground="#ce9178">"./src/main.js"</rich_text>
          <rich_text foreground="#d4d4d4"> </rich_text>
          <rich_text foreground="#9cdcfe">type</rich_text>
          <rich_text foreground="#d4d4d4">=</rich_text>
          <rich_text foreground="#ce9178">"module"</rich_text>
          <rich_text foreground="#808080">&gt;&lt;/</rich_text>
          <rich_text foreground="#569cd6">script</rich_text>
          <rich_text foreground="#808080">&gt;</rich_text>
          <rich_text>









</rich_text>
          <codebox char_offset="67" justification="left" frame_width="1305" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">import Bootloader from './../scenes/Bootloader.js';
//Esta es la configuración que tendra tu juego los atributos son muy explicitos.
const config = {
    //Con figuración opcional
    title: 'Curso phaser', //Titulo de tu juego
    url: 'http://google.es',//Pagina de tu juego
    version: '0.0.1', //Versión de tu juego
    //Configuración necesaria
    typo: Phaser.AUTO, //Tipo de rencerisado existen Phaser.AUTO, Phaser.CANVAS y Phaser.WEBGL
    width: 640,
    height: 360,
    parent: 'contenedor', //En esta opción se tiene que colocar el id del div de en donde se va a renderizar el juego
    pixelArt: true, //Solo se usa si esta desarrollado para pixelart
    backgroundColor: '#34495e', //Cambia el color de fondo del juego
    //Esto edita la información mostrada del proyecto en consola.
    banner: {
        hidePhaser: true,
        text: '#fff00f',
        background: ['#ff0000'] //Pedemos pasar varios colores
    },
    //Aqui se crean los mundos de phaser por escenas
    scene: [Bootloader]
};

//Por ultimos instanciamos Phaser para crear el primer proyecto
const game = new Phaser.Game(config);

Tambien exportar desdes la escena:

class Bootloader extends Phaser.Scene {
    constructor(){
        super({
            key: 'Bootloader'
        });
    }
    init(){
        console.log("init");
    }
    preload() {
        console.log("preload");
    }
    create(){
        console.log("create");
    }
    update(time, delta){

    }
}
export default Bootloader;</codebox>
          <codebox char_offset="188" justification="left" frame_width="787" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">import SceneC from '../scenes/SceneC.js';

class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['imgA', 'imgB', 'imgC']);
    }
    create() {
        this.scene.add('SceneC', SceneC);

        this.scene.start('SceneA');
        this.scene.launch('SceneB');
        this.scene.launch('SceneC');

        // this.scene.sleep('SceneA');
        // setTimeout(() =&gt; {
        //     this.scene.wake('SceneA');
        // }, 4000);

        // setTimeout(() =&gt; {
        //     this.scene.pause('SceneA');
        // }, 2000);
        // setTimeout(() =&gt; {
        //     this.scene.resume('SceneA');
        // }, 4000);

        // this.scene.stop('SceneC');
        // this.scene.remove('SceneC');

        // this.scene.moveDown('SceneC');
        // this.scene.moveUp('SceneA');
        
		Cambia de posición con otra escena
        // this.scene.swapPosition('SceneA', 'SceneC');
        Se pone aledante de todo
        // this.scene.bringToTop('SceneA');
        
        // this.scene.moveAbove('SceneA', 'SceneC');
        // this.scene.moveBelow('SceneA', 'SceneC');

        // this.scene.sendToBack('SceneC');
        console.log(this.scene.manager.scenes.map( x =&gt; x.scene.key));
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
          <codebox char_offset="191" justification="left" frame_width="500" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class SceneA extends Phaser.Scene {
    constructor() {
        super({key: 'SceneA'});
    }
    init() {
        console.log('Scene SceneA');
    }
    create() {
        this.add.image(100, 100, 'imgA');
    }
    update(time, delta) {
        // console.log(time);
    }
}

export default SceneA;</codebox>
          <codebox char_offset="194" justification="left" frame_width="500" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class SceneB extends Phaser.Scene {
    constructor() {
        super({key: 'SceneB'});
    }
    init() {
        console.log('Scene SceneB');
    }
    create() {
        this.add.image(100, 100, 'imgB');
    }
    update(time, delta) {
       
    }
}

export default SceneB;</codebox>
          <codebox char_offset="197" justification="left" frame_width="500" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class SceneC extends Phaser.Scene {
    constructor() {
        super({key: 'SceneC'});
    }
    init() {
        console.log('Scene SceneC');
    }
    create() {
        this.add.image(100, 100, 'imgC');
        // this.scene.stop();
    }
    update(time, delta) {
       
    }
}

export default SceneC;</codebox>
        </node>
      </node>
    </node>
    <node name="Cargar sprites" unique_id="10" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585850335" ts_lastsave="1586188588">
      <rich_text>Para la comprensión de todos los aspectos de el uso de sprites tenemos que ver la documentasión:

</rich_text>
      <rich_text link="webs https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Image.html">https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Image.html</rich_text>
      <rich_text>
</rich_text>
      <rich_text link="file QzpcVXNlcnNcVWx0cm9uXERvY3VtZW50c1xHaXRcRG9jdW1lbnRhY2lvblw1LVBoYXNlclxvcmlnaW5hbC5wZGY=">PDF</rich_text>
      <rich_text>

</rich_text>
      <rich_text justification="left"></rich_text>
      <codebox char_offset="176" justification="left" frame_width="2119" frame_height="500" width_in_pixels="1" syntax_highlighting="js" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor(){
        super({
            key: 'Bootloader'
        });
    }
    init(){
        console.log("init");
    }
    preload() {
        console.log("preload");
        this.load.path = './src/assets/';//Sirve para crear la ruta de las imagenes
        //load.image('cubix_fondo', 'cubix_fondo.png');//Con esto creamos la imagen
        //this.load.image('cubix');//Tambien phaser internamente crea las extenciones por lo que se puede sar solo su nombre
        this.load.image(['cubix_fondo', 'cubix'])//Esta es otra opción más corta para cargar imagenes equivalente a las dos lineas anteriores
    }
    create(){
        console.log("create");
        this.cubix_fondo = this.add.image(100, 100, 'cubix_fondo');//Crea la imagen y la posiciona
        this.cubix = this.add.image(130, 130, 'cubix');//Crea la imagen y la posiciona

        this.cubix.setOrigin(1);//Cambia el punto de origne de la imagen, 1 toma las coordenadas hasta abajo a la derecha equivalente a transform-origin: bottom left; los valores van de 0 a 1
        this.cubix.flipX = true;//Voltea la imagen, tambien tiene flipY para voltear de cabeza
        this.cubix.setVisible(1);//Oculta una imagen 1 es visible 0 la oculta pero la imagen sigue ahi.
        this.cubix.setScale(2);//Escala una imagen. se puede escalar en X e Y. (2, 1)
        //this.cubix.setAlpha(0);//Transparencia de 1 a 0
        this.cubix.setTint(0xff0000);//Tinta la imagen es decir cambia el color hacia el que se declara pero solo funciona en WEBGl
        this.cubix.x = 200; //Mueve la imagen. tambien exite y
        //this.cubix.angle = 10;//Angulo
        //this.cubix.rotation = 10;//rotación
        this.cubix.setDepth(1);//Propiedades iguales a z-index
        this.cubix_fondo.setDepth(2);//Propiedades iguales a z-index
        console.log(this.cubix);//Podemos ver que propiedades tiene.
    }
    update(time, delta){

    }
}
export default Bootloader;</codebox>
      <node name="animar sprites" unique_id="15" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1586188588" ts_lastsave="1586188592">
        <node name="Atlas" unique_id="16" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1586188605" ts_lastsave="1586188642">
          <rich_text>Para creación de atlas usamos la siguiente pagina:

</rich_text>
          <rich_text link="webs https://gammafp.com/tool/atlas-packer/">https://gammafp.com/tool/atlas-packer/</rich_text>
          <rich_text>

</rich_text>
          <rich_text link="webs https://gammafp.com/tools/">https://gammafp.com/tools/</rich_text>
        </node>
      </node>
    </node>
    <node name="Input/control" unique_id="11" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585860201" ts_lastsave="1585860314">
      <node name="Teclado" unique_id="12" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585860282" ts_lastsave="1585873833">
        <rich_text>Todas las teclas tienen un valor numerico con las que se identifican para conoser esto valores podemos escribir dentro de una escena:

</rich_text>
        <rich_text foreground="#569cd6">const</rich_text>
        <rich_text foreground="#d4d4d4"> </rich_text>
        <rich_text foreground="#9cdcfe">keyCodes</rich_text>
        <rich_text foreground="#d4d4d4"> = </rich_text>
        <rich_text foreground="#4ec9b0">Phaser</rich_text>
        <rich_text foreground="#d4d4d4">.</rich_text>
        <rich_text foreground="#4ec9b0">Input</rich_text>
        <rich_text foreground="#d4d4d4">.</rich_text>
        <rich_text foreground="#4ec9b0">Keyboard</rich_text>
        <rich_text foreground="#d4d4d4">.</rich_text>
        <rich_text foreground="#4ec9b0">KeyCodes</rich_text>
        <rich_text foreground="#d4d4d4">;        </rich_text>
        <rich_text foreground="#9cdcfe">console</rich_text>
        <rich_text foreground="#d4d4d4">.</rich_text>
        <rich_text foreground="#dcdcaa">log</rich_text>
        <rich_text foreground="#d4d4d4">(</rich_text>
        <rich_text foreground="#9cdcfe">keyCodes</rich_text>
        <rich_text foreground="#d4d4d4">);</rich_text>
        <rich_text>

</rich_text>
      </node>
      <node name="Puntero" unique_id="13" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585860293" ts_lastsave="1737826542">
        <rich_text>
</rich_text>
        <rich_text justification="left"></rich_text>
        <rich_text>

</rich_text>
        <rich_text justification="left"></rich_text>
        <codebox char_offset="1" justification="left" frame_width="942" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
    }
    create() {
        this.cubix = this.add.image(100, 100, 'cubix').setInteractive();
        this.cubix_fondo = this.add.image(100, 200, 'cubix_fondo').setInteractive();
        // Crea un constante con los eventos
        const eventos = Phaser.Input.Events;
        //Eventos del mauser
        this.input.on(eventos.POINTER_DOWN, (evento) =&gt; {
            // console.log("Se ha clicado en el CANVAS");
            // console.log(evento);
        });
        this.input.on(eventos.POINTER_UP, (evento) =&gt; {
            // console.log("Se ha levantado el puntero en el CANVAS");
        });
        // movimiento del mause
        this.input.on(eventos.POINTER_MOVE, (evento) =&gt; {
            if(evento.isDown) {
                this.cubix.x = evento.worldX;
                this.cubix.y = evento.worldY;
            }
        });
        // Se ejecuta cuando estas en el juego
        this.input.on(eventos.GAME_OVER, () =&gt; {
            console.log('Has entrado en el lienzo');
        });
        // Se ejecuta cuando sale del juego
        this.input.on(eventos.GAME_OUT, () =&gt; {
            // console.log('Has salido en el lienzo');
        });
        // Si se dar click fuera del juego
        this.input.on(eventos.POINTER_DOWN_OUTSIDE, () =&gt; {
            // console.log('HAS CLICADO FUERA DEL LIENZO');
        });
        this.input.on(eventos.POINTER_UP_OUTSIDE, () =&gt; {
            // console.log('HAS LEVANTADO FUERA DEL LIENZO');
        });

        // this.input.on(eventos.GAMEOBJECT_DOWN, (pointer, gameObject) =&gt; {
        //     gameObject.setTint(0x00ff00);
        // });
        // this.input.on(eventos.GAMEOBJECT_UP, (pointer, gameObject) =&gt; {
        //     gameObject.clearTint();
        // });

        // this.input.on(eventos.GAMEOBJECT_OVER, (pointer, gameObject) =&gt; {
        //     gameObject.setTint(0x0000ff);
        // });
        // this.input.on(eventos.GAMEOBJECT_OUT, (pointer, gameObject) =&gt; {
        //     gameObject.clearTint();
        // });
        this.cubix_fondo.on(eventos.POINTER_DOWN, function() {
            this.setTint(0x00ff00);
        });
        this.cubix_fondo.on(eventos.POINTER_UP, function() {
            this.clearTint();
        });
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
        <codebox char_offset="4" justification="left" frame_width="1228" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
    }
    create() {
        this.cubix = this.add.image(100, 100, 'cubix');
        const events = Phaser.Input.Events;
        const keyboard = Phaser.Input.Keyboard;
        // Bloqueamos el puntero
        this.input.on(events.POINTER_DOWN, () =&gt; {
            this.input.mouse.requestPointerLock();
        });
        // Se bloquea el puntero pero se puede seguir moviendo un objeto con el se podria cambiar por una mira
        this.input.on(events.POINTER_MOVE, (pointer) =&gt; {
            if(this.input.mouse.locked) {
                this.cubix.x += pointer.movementX;
                this.cubix.y += pointer.movementY;
            }
        });
        // Bloqueamos el puntero con una tecla             this.input.keyboard.addKey(keyboard.KeyCodes.A)
        .on('down', () =&gt; {
            this.input.mouse.releasePointerLock();
        });
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
      </node>
      <node name="Drag and drop" unique_id="14" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1585860314" ts_lastsave="1738048407">
        <rich_text justification="left"></rich_text>
        <codebox char_offset="0" justification="left" frame_width="1239" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">
  // Declaración mínima - Inicio
  // Crear objeto draggable
  this.cubix = this.add.image(100, 100, 'cubix').setInteractive();
  this.input.setDraggable(this.cubix);

  // Crear zona de drop y gráfico asociado
  this.drop = this.add.zone(100, 250, 100, 100).setRectangleDropZone(100, 100);
  const dropGraphics = this.add.graphics();
  dropGraphics.fillStyle(0x00ff00, 0.5); // Verde inicial
  dropGraphics.fillRect(
    this.drop.x - this.drop.input.hitArea.width / 2,
    this.drop.y - this.drop.input.hitArea.height / 2,
    this.drop.input.hitArea.width,
    this.drop.input.hitArea.height
  );

  const eventos = Phaser.Input.Events;

  // Configurar eventos de arrastre
  this.input.on(
    eventos.DRAG_START,
    (pointer: Phaser.Input.Pointer, obj: Phaser.GameObjects.GameObject) =&gt; {
      const sprite = obj as Phaser.GameObjects.Image;
      sprite.setScale(0.9); // Reducir escala al comenzar a arrastrar
    }
  );

  this.input.on(
    eventos.DRAG,
    (pointer: Phaser.Input.Pointer, obj: Phaser.GameObjects.GameObject, dragX: number, dragY: number) =&gt; {
      const sprite = obj as Phaser.GameObjects.Image;
      sprite.x = dragX;
      sprite.y = dragY;
    }
  );

  this.input.on(
    eventos.DRAG_END,
    (
      pointer: Phaser.Input.Pointer,
      obj: Phaser.GameObjects.GameObject,
      dropzone: Phaser.GameObjects.Zone
    ) =&gt; {
      const sprite = obj as Phaser.GameObjects.Image;

      // Si está en una zona de drop
      if (dropzone) {
        console.log('Entró en la zona');
        dropGraphics.clear();
        dropGraphics.fillStyle(0xff0000, 0.5); // Cambiar a rojo
        if (dropzone.input)
        dropGraphics.fillRect(
          dropzone.x - dropzone.input.hitArea.width / 2,
          dropzone.y - dropzone.input.hitArea.height / 2,
          dropzone.input.hitArea.width,
          dropzone.input.hitArea.height
        );
      } else {
        // Si no está en una zona de drop, regresa al punto inicial
        if (sprite.input) {

        }
        
      }

      // Restaurar tamaño del objeto
      sprite.setScale(1);
    }
  );

  this.input.on(
    eventos.DRAG_ENTER,
    (pointer: Phaser.Input.Pointer, obj: Phaser.GameObjects.GameObject, dropzone: Phaser.GameObjects.Zone) =&gt; {
      // Cambiar a amarillo cuando entra
      dropGraphics.clear();
      dropGraphics.fillStyle(0xffff00, 0.5); // Amarillo
      if (dropzone.input)
      dropGraphics.fillRect(
        dropzone.x - dropzone.input.hitArea.width / 2,
        dropzone.y - dropzone.input.hitArea.height / 2,
        dropzone.input.hitArea.width,
        dropzone.input.hitArea.height
      );
    }
  );

  this.input.on(
    eventos.DRAG_LEAVE,
    (pointer: Phaser.Input.Pointer, obj: Phaser.GameObjects.GameObject, dropzone: Phaser.GameObjects.Zone) =&gt; {
      // Cambiar a verde cuando sale
      dropGraphics.clear();
      dropGraphics.fillStyle(0x00ff00, 0.5); // Verde
      if (dropzone.input)
      dropGraphics.fillRect(
        dropzone.x - dropzone.input.hitArea.width / 2,
        dropzone.y - dropzone.input.hitArea.height / 2,
        dropzone.input.hitArea.width,
        dropzone.input.hitArea.height
      );
    }
  );

  this.input.on(
    eventos.DRAG_LEAVE,
    (pointer: Phaser.Input.Pointer, obj: Phaser.GameObjects.GameObject, dropzone: Phaser.GameObjects.Zone) =&gt; {
      // Cambiar a verde cuando sale
      dropGraphics.clear();
      dropGraphics.fillStyle(0x00ff00, 0.5); // Verde
      if (dropzone.input)
      dropGraphics.fillRect(
        dropzone.x - dropzone.input.hitArea.width / 2,
        dropzone.y - dropzone.input.hitArea.height / 2,
        dropzone.input.hitArea.width,
        dropzone.input.hitArea.height
      );
    }
  );

  this.input.on(
    eventos.DROP,
    (pointer: Phaser.Input.Pointer, obj: Phaser.GameObjects.GameObject, dropzone: Phaser.GameObjects.Zone) =&gt; {
      // Convertimos el objeto a tipo Image
      const sprite = obj as Phaser.GameObjects.Image;
  
      // Ajustar automáticamente el objeto al centro de la zona
      sprite.x = dropzone.x;
      sprite.y = dropzone.y;
  
      console.log('El objeto se ajustó al centro de la zona de drop');
    }
  );</codebox>
      </node>
    </node>
    <node name="Interpolaciones" unique_id="17" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1586194032" ts_lastsave="1738389399">
      <rich_text>Los tweens o interpolaciones nos ayuda a llegar de una fase a otra de manera gradual.



tipo de interpolación:
Power0 
    Power1 
    Power2 
    Power3 
    Power4 
    Linear 
    Quad 
    Cubic 
    Quart 
    Quint 
    Sine 
    Expo 
    Circ 
    Elastic 
    Back 
    Bounce 
    Stepped 
    Quad.easeIn 
    Cubic.easeIn 
    Quart.easeIn 
    Quint.easeIn 
    Sine.easeIn 
    Expo.easeIn 
    Circ.easeIn 
    Elastic.easeIn 
    Back.easeIn 
    Bounce.easeIn 
    
    Quad.easeOut 
    Cubic.easeOut 
    Quart.easeOut 
    Quint.easeOut 
    Sine.easeOut 
    Expo.easeOut 
    Circ.easeOut 
    Elastic.easeOut 
    Back.easeOut 
    Bounce.easeOut 

    Quad.easeInOut 
    Cubic.easeInOut 
    Quart.easeInOut 
    Quint.easeInOut 
    Sine.easeInOut 
    Expo.easeInOut 
    Circ.easeInOut 
    Elastic.easeInOut 
    Back.easeInOut 
    Bounce.easeInOut</rich_text>
      <codebox char_offset="87" justification="left" frame_width="788" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
    }
    create() {
        this.cubix = this.add.image(100, 100, 'cubix');
        // this.cubix_fondo = this.add.image(160, 100, 'cubix_fondo');
        // console.log(this.cubix);
        this.tweens = this.add.tween({
            targets: [this.cubix],
            // ease: 'Bounce',
            duration: 1000,
            y: 300,
            // x: {
            //     value: 200,
            //     ease: 'Elastic',
            //     duration: 3000
            // },
            repeat: 0,
            yoyo: true,
            // delay: 1000
            // hold: 1000
            // repeatDelay: 1000,
            onStart: () =&gt; {
                console.log('Inicia la tween');
            },
            onRepeat: () =&gt; {
                console.log('Se ha repetido');
            },
            onYoyo: (tween, obj, target) =&gt; {
                target.setTint(0xff0000);
                console.log('Se ha hecho YOYO');
            },
            onComplete: (tween, obj, target) =&gt; {
                // target.setTint(0xff0000);
                console.log('Has completado el tween');
            },
            onYoyoParams: [this.cubix]
            // onCompleteParams: [this.cubix]
        });
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
    </node>
    <node name="Timelines" unique_id="21" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738389431" ts_lastsave="1738389589">
      <rich_text></rich_text>
      <codebox char_offset="0" justification="left" frame_width="634" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
    }
    create() {
        this.cubix = this.add.image(100, 100, 'cubix');
        this.timeline = this.tweens.timeline({
            targets: [this.cubix],
            // duration: 2000,
            // totalDuration: 1000,
            // paused: true,
            loop: -1,
            tweens: [
                {
                    x: 300,
                },
                {
                    y: 300,
                    // offset: "-=500"
                },
                {
                    x: 100
                },
                {
                    y: 100
                },
            ]
        });
        // this.timeline.play();
        
        // this.timeline = this.tweens.createTimeline();

        // this.timeline.add({
        //     targets: [this.cubix],
        //     x: 300,
        //     ease: 'Bounce'
        // });
        // this.timeline.add({
        //     targets: [this.cubix],
        //     y: 300
        // });
        // this.timeline.add({
        //     targets: [this.cubix],
        //     x: 100
        // });
        // this.timeline.add({
        //     targets: [this.cubix],
        //     y: 100
        // });

        // this.timeline.play();

    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
    </node>
    <node name="Subir juego" unique_id="18" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1586214810" ts_lastsave="1586214826">
      <rich_text>Es una pagina que nos permite publicar nuestro juegos y obtener ganancias de el:

</rich_text>
      <rich_text link="webs https://itch.io/">https://itch.io/</rich_text>
    </node>
    <node name="Crear funtes" unique_id="19" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1586275757" ts_lastsave="1586275773">
      <rich_text>Esta pagina nos permite crear funtes personalizadas:

</rich_text>
      <rich_text link="webs http://ttf2png.ga/">http://ttf2png.ga/</rich_text>
      <rich_text>

para cargar las fuentes personalizadas y poder usar las en phaser se tienen que cargar en el index con el siguite codigo:

</rich_text>
      <rich_text foreground="#c586c0">@font-face</rich_text>
      <rich_text foreground="#d4d4d4"> {</rich_text>
      <rich_text>
    </rich_text>
      <rich_text foreground="#9cdcfe">font-family</rich_text>
      <rich_text foreground="#d4d4d4">: </rich_text>
      <rich_text foreground="#ce9178">'IndieFlower'</rich_text>
      <rich_text foreground="#d4d4d4">;</rich_text>
      <rich_text>
    </rich_text>
      <rich_text foreground="#9cdcfe">src</rich_text>
      <rich_text foreground="#d4d4d4">: </rich_text>
      <rich_text foreground="#dcdcaa">url</rich_text>
      <rich_text foreground="#d4d4d4">(</rich_text>
      <rich_text foreground="#ce9178">'./IndieFlower.ttf'</rich_text>
      <rich_text foreground="#d4d4d4">);        
}</rich_text>
    </node>
    <node name="Audios" unique_id="20" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1586303687" ts_lastsave="1738418581">
      <rich_text>Para los audios se usa la siguiente pagina:

</rich_text>
      <rich_text link="webs https://gammafp.github.io/audio-sprite-gamma/">https://gammafp.github.io/audio-sprite-gamma/</rich_text>
      <rich_text>

esto nos ayuda a unir los audios y los separa como si fueran sprites.</rich_text>
      <node name="audio" unique_id="27" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738418527" ts_lastsave="1738418536">
        <rich_text></rich_text>
        <codebox char_offset="0" justification="left" frame_width="700" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
        this.load.audio('8bits', ['8bits.ogg']);
    }
    create() {
        this.cubix = this.add.image(100, 100, 'cubix');
        const miaudio = this.sound.add('8bits');

        const cursor = this.input.keyboard.createCursorKeys();

        // this.sound.pauseOnBlur = false;
        
        cursor.up.on('down', () =&gt; {
            this.sound.pauseAll();
            // this.tweens.add({
            //     targets: [miaudio],
            //     duration: 2000,
            //     volume: 0,
            //     ease: 'Power1'
            // });
            // miaudio.volume -= 0.1;
            // miaudio.mute = true;
            // miaudio.detune += 100;
            // miaudio.rate -= 0.1;
            // miaudio.pause();
        });
        cursor.down.on('down', () =&gt; {
            this.sound.resumeAll();
            // miaudio.volume = 1;
            // miaudio.mute = false;
            // miaudio.detune = 1;
            // miaudio.rate = 1;
            // miaudio.resume();
        });
        cursor.left.on('down', () =&gt; {
            // miaudio.stop();
            this.sound.stopAll();
        });
        cursor.right.on('down', () =&gt; {
            miaudio.play();
        });

    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
      </node>
      <node name="sprite" unique_id="28" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738418581" ts_lastsave="1738418633">
        <rich_text>
</rich_text>
        <codebox char_offset="0" justification="left" frame_width="1107" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.audioSprite('fx', 'AUDIO/spriteAudioGamma.json', ['AUDIO/spriteAudioGamma.ogg']);
    }
    create() {
        const cursor = this.input.keyboard.createCursorKeys();
        cursor.left.on('down', () =&gt; {
            console.log('clap');
            this.sound.playAudioSprite('fx', 'clap');
        });
        cursor.up.on('down', () =&gt; {
            console.log('percusion');
            this.sound.playAudioSprite('fx', 'percusion');
        })
        cursor.right.on('down', () =&gt; {
            console.log('pop');
            this.sound.playAudioSprite('fx', 'pop');
        })
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
      </node>
    </node>
    <node name="Textos" unique_id="22" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738389884" ts_lastsave="1738389908">
      <node name="Estaticos" unique_id="23" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738389894" ts_lastsave="1738389953">
        <rich_text></rich_text>
        <codebox char_offset="0" justification="left" frame_width="656" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
    }
    create() {
        // this.cubix = this.add.image(100, 100, 'cubix');
        const texto = {
            x: 100, 
            y: 100, 
            text: 'Hola mundo\nque tal', 
            style: {
                fontFamily: 'IndieFlower',
                color: '#000000',
                fontSize: 40,
                backgroundColor: '#ffffff',
                fontStyle: 'Italic',
                padding: {
                    top: 20,
                    bottom: 20,
                    right: 20,
                    left: 20,
                },
                // align: 'left'
            }
        }
        
        this.nuevoTexto = this.make.text(texto);
        this.nuevoTexto.setText('Nuevo texto');
        // texto.setText('Soy un nuevo texto');
        // texto.flipX = true;
        // texto.alpha = 0.5;
        // texto.x = 0;
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
      </node>
      <node name="Retro" unique_id="24" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738389908" ts_lastsave="1738390069">
        <rich_text></rich_text>
        <codebox char_offset="0" justification="left" frame_width="1184" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);

        this.load.image('fuente', 'fuentes/fuente.png');
        this.load.json('fuente_json', 'fuentes/fuente.json');
    }
    create() {
        const fuenteConfig = this.cache.json.get('fuente_json');
        this.cache.bitmapFont.add('nombreFuente', Phaser.GameObjects.RetroFont.Parse(this, fuenteConfig));
        this.texto = this.add.bitmapText(50, 100, 'nombreFuente', 'PUNTOS 0', 30, 0).setTint(0xffee00);
        this.puntos = 0;

    }
    update(time, delta) {
        this.puntos++;
        this.texto.setText('PUNTOS ' + this.puntos);
       
    }
}

export default Bootloader;</codebox>
      </node>
    </node>
    <node name="Contenedores" unique_id="25" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738390243" ts_lastsave="1738417968">
      <rich_text></rich_text>
      <codebox char_offset="0" justification="left" frame_width="799" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
        this.load.image('contenedor', 'contenedor.png');
    }
    create() {
        this.cubix = this.add.image(300, 100, 'cubix')
        .setScale(.7)
        .setDepth(2);
        this.contenedor = this.add.image(200, 100, 'contenedor');
        this.texto = this.add.text(90, 90, 'PUNTOS 0', {fontSize: 30});
    
        const container = this.add.container(0, -300);
        container.add([
            this.contenedor,
            this.cubix,
            this.texto
        ]);


        this.add.tween({
            targets: [container],
            ease: 'Bounce',
            y: 100,
        });
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
      <node name="Grupos" unique_id="26" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738390253" ts_lastsave="1738418029">
        <rich_text></rich_text>
        <codebox char_offset="0" justification="left" frame_width="964" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.atlas('monedas', 'moneda/monedas.png', 'moneda/monedas_atlas.json');
        this.load.animation('monedaAnim', 'moneda/monedas_anim.json');
    }
    create() {
        // this.moneda = this.add.sprite(100, 100, 'monedas');
        this.grupo = this.add.group({
            key: 'monedas',
            repeat: 5,
            maxSize: 3,
            setXY: {
                x: 90,
                y: 150,
                stepX: 50,
                // stepY: 50
            },
            removeCallback: () =&gt; {
                this.grupo.create(150, 100, 'monedas');
            }
        });
        
        this.add.tween({
            targets: this.grupo.getChildren(),
            y: 200,
            yoyo: true,
            duration: 500,
            repeat: -1,
            ease: 'Power1'
        });
        this.grupo.getChildren()[1].destroy();
        // this.grupo.add(this.moneda);
        // this.grupo.create(150, 200, 'monedas');

        this.grupo.children.iterate( (moneda) =&gt; {
            moneda.setScale(4);
            // moneda.body.setAllowGravity(false);
            // moneda.anims.play('moneda');
        });

        this.grupo.playAnimation('moneda');
        console.log(this.grupo.getChildren());
        
        // this.moneda.anims.play('moneda');
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
      </node>
    </node>
    <node name="Datos, eventos y físicas" unique_id="29" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738418699" ts_lastsave="1738418813">
      <node name="Datos y eventos" unique_id="30" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738418759" ts_lastsave="1738418783">
        <rich_text>


</rich_text>
        <codebox char_offset="0" justification="left" frame_width="689" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        // this.registry.events.on('evento', (dato) =&gt; {
        //     console.log('Se ha emitido el evento ', dato);
        // });
    }
    create() {      
        this.scene.start('SceneA', 200);

        // this.data.set('vidas', 5);
        // this.data.set('monedas', 3);
        // this.data.set('monsters', 3);

        // // this.data.list.vidas -= 2;
        // // this.data.remove('monedas');
        // this.data.reset();
        // console.log(this.data.query('mon'))
    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
        <codebox char_offset="3" justification="left" frame_width="612" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class SceneA extends Phaser.Scene {
    constructor() {
        super('SceneA');
    }
    init(dato) {
        console.log('Has hecho estos puntos: ', dato);
    }
    preload() {
        // this.registry.events.emit('evento', 200);
    }
}

export default SceneA;</codebox>
      </node>
      <node name="Físicas arcade" unique_id="31" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1738418813" ts_lastsave="1738418852">
        <rich_text></rich_text>
        <codebox char_offset="0" justification="left" frame_width="788" frame_height="100" width_in_pixels="1" syntax_highlighting="ts" highlight_brackets="1" show_line_numbers="0">class Bootloader extends Phaser.Scene {
    constructor() {
        super('Bootloader');
    }
    init() {
        console.log('Scene Bootloader');
    }
    preload() {
        this.load.path = './assets/';
        this.load.image(['cubix', 'cubix_fondo']);
    }
    create() {
        this.cubix = this.physics.add.image(100, 100, 'cubix');
        this.evil_cubix = this.add.image(300, 100, 'cubix_fondo');
        this.physics.add.existing(this.evil_cubix);

        this.cubix.body.maxVelocity.x = 500;
        this.cubix.body.setMass(1);

        this.cubix.body.setCircle(40);
        this.cubix.body.setBounce(0.2);

        this.evil_cubix.body.setMass(1);
        this.evil_cubix.body.setSize(30, 30);
        this.evil_cubix.body.setOffset(30, 50);

        this.cubix.body.setCollideWorldBounds(true);
        this.evil_cubix.body.setCollideWorldBounds(true);

        this.cursor = this.input.keyboard.createCursorKeys();
        
        this.cursor.right.on('down', () =&gt; {
            this.cubix.body.setAcceleration(800);
        });

        this.cursor.up.on('down', () =&gt; {
            this.evil_cubix.body.setVelocityY(-400);
        });
        
        this.physics.add.collider(this.cubix, this.evil_cubix, () =&gt; {
            this.cubix.body.setVelocity(0);
            this.cubix.body.setAcceleration(0);
        });

    }
    update(time, delta) {
       
    }
}

export default Bootloader;</codebox>
      </node>
    </node>
  </node>
</cherrytree>
